<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <title>La Sciampista · Assistente AI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #f7efe9;
        color: #1f1f1f;
        font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
        -webkit-font-smoothing: antialiased;
      }
      body { display: flex; flex-direction: column; overflow: hidden; }

      header {
        padding: 10px 14px;
        font-size: .8rem;
        letter-spacing: .12em;
        text-transform: uppercase;
        color: #6a5b54;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255,255,255,0.6);
        backdrop-filter: blur(8px);
        border-bottom: 1px solid rgba(0,0,0,0.05);
        z-index: 1000;
      }
      header .brand { color: #b47a72; font-weight: 600; }

      .app-wrapper {
        position: relative;
        flex: 1;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      .frame-9-16 {
        position: relative;
        width: 100vw;
        max-width: 540px;
        aspect-ratio: 9/16;
        overflow: hidden;
        background: #000;
      }

      #heygen-streaming-embed {
        position: absolute !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
        border: none !important;
        border-radius: 0 !important;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }
      #heygen-streaming-embed.show {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
        transition: opacity .3s ease-out;
      }
      #heygen-streaming-container,
      #heygen-streaming-container iframe {
        width: 100% !important;
        height: 100% !important;
        border: 0 !important;
      }

      .hint-mobile {
        position: absolute;
        bottom: 10px;
        left: 0;
        right: 0;
        text-align: center;
        font-size: .75rem;
        color: #fff;
        background: rgba(0,0,0,0.35);
        padding: 8px 10px;
        border-radius: 12px;
        margin: 0 10px;
        z-index: 50;
      }
      .hint-mobile strong { font-weight: 700; }

      .pill {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 60;
        font-size: .75rem;
        color: #fff;
        background: rgba(0,0,0,0.35);
        padding: 6px 10px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        user-select: none;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #888;
        box-shadow: 0 0 0 2px rgba(255,255,255,0.12) inset;
      }
      .dot.on { background: #46d369; }

      #presence-video, #presence-canvas {
        position: absolute;
        width: 1px;
        height: 1px;
        opacity: 0;
        pointer-events: none;
        left: -9999px;
        top: -9999px;
      }
    </style>
  </head>

  <body>
    <header>
      <div class="brand">La Sciampista · AI</div>
      <div class="hint">Consulente capelli naturale</div>
    </header>

    <div class="app-wrapper">
      <div class="frame-9-16" id="frame">
        <div class="pill" aria-live="polite">
          <span class="dot" id="presenceDot"></span>
          <span id="presenceText">In attesa di presenza…</span>
        </div>

        <div class="pill" style="top:44px" aria-live="polite">
          <span id="debugText">init…</span>
        </div>

        <div class="hint-mobile" id="hintMobile">
          <strong>Avvicinati</strong> e l’avatar si attiva automaticamente.<br/>
          Al primo avvio potrebbe essere necessario <strong>toccare lo schermo</strong> per abilitare il microfono.
        </div>

        <video id="presence-video" playsinline muted></video>
        <canvas id="presence-canvas"></canvas>
      </div>
    </div>

    <script>
      (function(){
        const host="https://labs.heygen.com";
        const url=host+"/guest/streaming-embed?share=eyJxdWFsaXR5IjoiaGlnaCIsImF2YXRhck5hbWUiOiJLYXR5YV9Qcm9mZXNzaW9uYWxMb29rX3B1%0D%0AYmxpYyIsInByZXZpZXdJbWciOiJodHRwczovL2ZpbGVzMi5oZXlnZW4uYWkvYXZhdGFyL3YzLzM0%0D%0AOGRkZjUwM2M2NTRiOWJiYmI4YmVhOWY5MjEwZWFkXzU1ODcwL3ByZXZpZXdfdGFyZ2V0LndlYnAi%0D%0ALCJuZWVkUmVtb3ZlQmFja2dyb3VuZCI6dHJ1ZSwia25vd2xlZGdlQmFzZUlkIjoiY2E3M2VmNmY2%0D%0AOTdhNGFhMTgzZGM1MzZkY2EyMDY3YmYiLCJ1c2VybmFtZSI6ImZiNDBjZGI1NjdlZjRjMTg5MDM4%0D%0ANDkwODI5YzIwZTZmIn0%3D&inIFrame=1";

        const frame = document.getElementById("frame");

        // Embed wrapper
        const wrapDiv=document.createElement("div");
        wrapDiv.id="heygen-streaming-embed";
        const container=document.createElement("div");
        container.id="heygen-streaming-container";
        const iframe=document.createElement("iframe");
        iframe.allowFullscreen=false;
        iframe.title="La Sciampista AI";
        iframe.role="dialog";
        iframe.allow="microphone; camera; autoplay";
        iframe.src=url;
        container.appendChild(iframe);
        wrapDiv.appendChild(container);
        frame.appendChild(wrapDiv);

        // UI refs
        const videoEl = document.getElementById("presence-video");
        const canvasEl = document.getElementById("presence-canvas");
        const ctx = canvasEl.getContext("2d", { willReadFrequently: true });

        const presenceDot = document.getElementById("presenceDot");
        const presenceText = document.getElementById("presenceText");
        const hintMobile = document.getElementById("hintMobile");
        const debugText = document.getElementById("debugText");

        function setPresenceUI(on){
          presenceDot.classList.toggle("on", on);
          presenceText.textContent = on ? "Presenza rilevata · Attivo chat…" : "In attesa di presenza…";
        }

        function showHeyGen(){
          wrapDiv.classList.add("show");
          hintMobile.style.display = "none";
        }

        function activateHeyGen(){
          showHeyGen();

          // Tentativi (solo se supportati dall’embed)
          try {
            iframe.contentWindow.postMessage({ type: "streaming-embed", action: "show" }, host);
            iframe.contentWindow.postMessage({ type: "streaming-embed", action: "start" }, host);
            iframe.contentWindow.postMessage({ type: "streaming-embed", action: "open" }, host);
          } catch(_) {}

          // click sintetico (non sempre accettato)
          try {
            iframe.dispatchEvent(new MouseEvent("click", { bubbles: true, cancelable: true, view: window }));
          } catch(_) {}
        }

        // Tap manuale = sblocca sempre
        frame.addEventListener("click", () => showHeyGen(), { passive: true });

        // ===============================
        // FACE DETECTION "PRESENCE LOCK"
        // ===============================
        const faceSupported = ("FaceDetector" in window);
        let faceDetector = null;

        // Lock management
        let isLocked = false;
        let lockUntilTs = 0;
        let lastFaceSeenTs = 0;
        let faceConsecutiveHits = 0;

        const FACE_SCAN_EVERY_MS = 350;   // ogni quanto controllare volti
        const FACE_REQUIRED_HITS = 2;     // 2 hit consecutivi = presence
        const FACE_GRACE_MS = 2500;       // se perde volto, mantiene lock per 2.5s
        const LOCK_MIN_MS = 12000;        // una volta attivato, resta "attivo" almeno 12s

        // ===============================
        // MOTION fallback (se FaceDetector manca)
        // ===============================
        let lastImageData = null;
        let motionConsecutiveHits = 0;
        let lastMotionTs = 0;

        // motion params (sensibili)
        const SAMPLE_W = 240;
        const SAMPLE_H = 180;
        const DIFF_THRESHOLD = 6;
        const MOTION_RATIO   = 0.0035;
        const MOTION_REQUIRED_HITS = 2;
        const MOTION_COOLDOWN_MS = 5000;

        function lockPresence(reason){
          const now = Date.now();
          isLocked = true;
          lastFaceSeenTs = now;
          lockUntilTs = Math.max(lockUntilTs, now + LOCK_MIN_MS);
          setPresenceUI(true);
          activateHeyGen();
          if (debugText) debugText.textContent = `LOCK ✅ (${reason})`;
        }

        function maybeUnlock(){
          const now = Date.now();
          const graceOk = (now - lastFaceSeenTs) <= FACE_GRACE_MS;
          const minLockOk = now <= lockUntilTs;

          if (minLockOk || graceOk) return; // resta lock

          isLocked = false;
          faceConsecutiveHits = 0;
          setPresenceUI(false);
          if (debugText) debugText.textContent = faceSupported ? "Face: idle" : "Motion: idle";
        }

        async function startCamera(){
          try {
            if (debugText) debugText.textContent = "camera: richiesta permesso…";

            const stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } },
              audio: false
            });

            videoEl.srcObject = stream;
            await videoEl.play();

            canvasEl.width = SAMPLE_W;
            canvasEl.height = SAMPLE_H;

            // setup face detector
            if (faceSupported) {
              faceDetector = new FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
              if (debugText) debugText.textContent = "FaceDetector: ON";
            } else {
              if (debugText) debugText.textContent = "FaceDetector: OFF (fallback motion)";
            }

            // fallback: se dopo 8s non si attiva nulla, mostra embed comunque
            setTimeout(() => {
              if (!wrapDiv.classList.contains("show")) {
                presenceText.textContent = "Presenza non rilevata · Avvio manuale";
                if (debugText) debugText.textContent = "fallback: show embed";
                showHeyGen();
              }
            }, 8000);

            // avvia loop combinato
            tick();

          } catch (err) {
            setPresenceUI(false);
            presenceText.textContent = "Camera non disponibile · Tocca per avviare";
            if (debugText) debugText.textContent = "camera: ERRORE/NEGATA";
            showHeyGen();
          }
        }

        let lastFaceScanTs = 0;

        async function tick(){
          const now = Date.now();

          // se già in lock, proviamo a mantenere/aggiornare “last seen”
          // e decidere eventuale unlock
          if (isLocked) {
            // Se FaceDetector disponibile, aggiorniamo lastFaceSeenTs quando vede un volto.
            // In caso contrario useremo il motion per tenere vivo lastFaceSeenTs.
            if (faceSupported && faceDetector && (now - lastFaceScanTs) >= FACE_SCAN_EVERY_MS) {
              lastFaceScanTs = now;
              const saw = await detectFaceOnce();
              if (saw) lastFaceSeenTs = now;
            } else if (!faceSupported) {
              const mot = detectMotionOnce();
              if (mot) lastFaceSeenTs = now;
            }

            maybeUnlock();
            requestAnimationFrame(tick);
            return;
          }

          // NON locked: cerchiamo presenza
          if (faceSupported && faceDetector) {
            if ((now - lastFaceScanTs) >= FACE_SCAN_EVERY_MS) {
              lastFaceScanTs = now;
              const saw = await detectFaceOnce();

              if (saw) {
                faceConsecutiveHits++;
                if (debugText) debugText.textContent = `Face: ✅ (${faceConsecutiveHits}/${FACE_REQUIRED_HITS})`;
                if (faceConsecutiveHits >= FACE_REQUIRED_HITS) lockPresence("face");
              } else {
                faceConsecutiveHits = Math.max(0, faceConsecutiveHits - 1);
                if (debugText) debugText.textContent = `Face: -- (${faceConsecutiveHits}/${FACE_REQUIRED_HITS})`;
              }
            }
          } else {
            // fallback motion
            const mot = detectMotionOnce();
            if (mot) {
              motionConsecutiveHits++;
            } else {
              motionConsecutiveHits = Math.max(0, motionConsecutiveHits - 1);
            }

            if (debugText) debugText.textContent =
              `Motion: ${mot ? "✅" : "--"} (${motionConsecutiveHits}/${MOTION_REQUIRED_HITS})`;

            if (motionConsecutiveHits >= MOTION_REQUIRED_HITS) {
              // cooldown motion
              if ((now - lastMotionTs) > MOTION_COOLDOWN_MS) {
                lastMotionTs = now;
                lockPresence("motion");
              }
            }
          }

          requestAnimationFrame(tick);
        }

        async function detectFaceOnce(){
          try {
            // creiamo un ImageBitmap dal video (molto leggero)
            const bmp = await createImageBitmap(videoEl);
            const faces = await faceDetector.detect(bmp);
            bmp.close?.();

            const saw = (faces && faces.length > 0);
            return saw;
          } catch (e) {
            // se FaceDetector fallisce (policy/bug), passiamo al fallback motion
            if (debugText) debugText.textContent = "FaceDetector errore → fallback motion";
            faceDetector = null;
            return false;
          }
        }

        function detectMotionOnce(){
          if (videoEl.readyState < 2) return false;

          ctx.drawImage(videoEl, 0, 0, SAMPLE_W, SAMPLE_H);
          const imageData = ctx.getImageData(0, 0, SAMPLE_W, SAMPLE_H);

          if (!lastImageData) {
            lastImageData = imageData;
            return false;
          }

          let changed = 0;
          const data = imageData.data;
          const last = lastImageData.data;

          // campionamento fitto
          for (let i = 0; i < data.length; i += 4) {
            const r = data[i], g = data[i+1], b = data[i+2];
            const lr = last[i], lg = last[i+1], lb = last[i+2];
            const diff = (Math.abs(r-lr) + Math.abs(g-lg) + Math.abs(b-lb)) / 3;
            if (diff > DIFF_THRESHOLD) changed++;
          }

          const totalSamples = (data.length / 4);
          const ratio = changed / totalSamples;

          lastImageData = imageData;

          // utile anche in debug quando siamo in fallback
          return ratio > MOTION_RATIO;
        }

        window.addEventListener("load", startCamera);
      })();
    </script>
  </body>
</html>
